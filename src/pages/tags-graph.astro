---
/**
 * /tags-graph — 知識圖譜：視覺化 pillar × tag × article 關聯
 * Inspired by mashbean.net/tags-graph/ (CC BY-NC 4.0)
 * Adapted for paulkuo.tw five-pillar architecture
 */
import { getCollection } from 'astro:content';
import BaseLayout from '../layouts/BaseLayout.astro';
import { PILLAR_MAP } from '../config';

const articles = (await getCollection('articles', ({ data }) => !data.draft))
  .sort((a, b) => b.data.date.getTime() - a.data.date.getTime())
  .slice(0, 120);

// Build tag frequency for top-N selection
const tagCounter = new Map<string, number>();
for (const a of articles) {
  for (const tag of a.data.tags || []) {
    tagCounter.set(tag, (tagCounter.get(tag) || 0) + 1);
  }
}
// Keep tags that appear 2+ times, take top 50
const topTags = Array.from(tagCounter.entries())
  .filter(([, count]) => count >= 2)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 50)
  .map(([tag]) => tag);
const tagSet = new Set(topTags);

// Build graph
type GraphNode = {
  id: string;
  type: 'pillar' | 'tag' | 'post';
  label: string;
  url?: string;
  pillar?: string;
  color?: string;
};
type GraphLink = {
  source: string;
  target: string;
  kind: 'pillar' | 'tag';
  weight: number;
};

const nodes: GraphNode[] = [];
const links: GraphLink[] = [];

// Pillar nodes
for (const [key, val] of Object.entries(PILLAR_MAP)) {
  nodes.push({ id: `pillar:${key}`, type: 'pillar', label: val.label, pillar: key, color: val.color });
}

// Tag nodes
for (const tag of topTags) {
  nodes.push({ id: `tag:${tag}`, type: 'tag', label: tag });
}

// Article nodes + links
for (const a of articles) {
  const slug = a.id.replace(/\.md$/, '');
  const pillarKey = a.data.pillar;
  nodes.push({
    id: `post:${slug}`,
    type: 'post',
    label: a.data.title,
    url: `/articles/${slug}/`,
    pillar: pillarKey,
  });
  // Link to pillar
  links.push({ source: `post:${slug}`, target: `pillar:${pillarKey}`, kind: 'pillar', weight: 1 });
  // Link to tags
  for (const tag of a.data.tags || []) {
    if (tagSet.has(tag)) {
      links.push({ source: `post:${slug}`, target: `tag:${tag}`, kind: 'tag', weight: 0.7 });
    }
  }
}

const graph = { nodes, links };
const pillars = Object.entries(PILLAR_MAP);
---

<BaseLayout title="知識圖譜 — Paul Kuo" description="視覺化呈現所有文章、標籤、五大支柱的關聯網絡">
  <section class="graph-page">
    <h1 class="graph-page-title">知識圖譜</h1>
    <p class="graph-intro">拖曳旋轉、滾輪縮放。點擊節點查看資訊，再點一次開啟文章。</p>

    <div class="graph-toolbar">
      <label>
        篩選支柱
        <select id="graph-pillar-filter">
          <option value="all">全部</option>
          {pillars.map(([key, val]) => <option value={key}>{val.label}</option>)}
        </select>
      </label>
      <label>
        搜尋
        <input id="graph-search" type="search" placeholder="文章或標籤..." />
      </label>
      <button id="graph-reset" type="button">重置</button>
      <a href="/tags" class="graph-toolbar-link">標籤列表</a>
    </div>

    <div class="graph-controls">
      <p id="graph-status" class="graph-status">全部節點</p>
      <div class="graph-type-toggle" role="group" aria-label="節點類型">
        <label><input type="checkbox" data-node-type="pillar" checked /><span class="dot dot-pillar"></span>支柱</label>
        <label><input type="checkbox" data-node-type="tag" checked /><span class="dot dot-tag"></span>標籤</label>
        <label><input type="checkbox" data-node-type="post" checked /><span class="dot dot-post"></span>文章</label>
      </div>
    </div>

    <div class="graph-main">
      <div id="graph-stage" class="graph-stage" role="application" aria-label="互動圖譜" tabindex="0"></div>
      <aside id="graph-inspector" class="graph-inspector" aria-live="polite">
        <div class="graph-inspector-head">
          <h2>節點資訊</h2>
          <button id="graph-inspector-close" type="button" aria-label="關閉">✕</button>
        </div>
        <div id="graph-inspector-content" class="graph-inspector-content">
          <p>點擊任一節點查看資訊。</p>
        </div>
      </aside>
    </div>
  </section>
</BaseLayout>

<script is:inline define:vars={{ graph }}>
// === 3D Force-Directed Graph (adapted from mashbean/blog, CC BY-NC 4.0) ===
const stage = document.getElementById('graph-stage');
const inspector = document.getElementById('graph-inspector');
const inspectorContent = document.getElementById('graph-inspector-content');
const inspectorClose = document.getElementById('graph-inspector-close');
const pillarFilter = document.getElementById('graph-pillar-filter');
const searchInput = document.getElementById('graph-search');
const statusEl = document.getElementById('graph-status');
const resetBtn = document.getElementById('graph-reset');
const typeCheckboxes = Array.from(document.querySelectorAll('.graph-type-toggle input[data-node-type]'));

if (!stage) throw new Error('graph stage missing');

// Pillar colors from CSS custom properties → fallback hex
const PILLAR_COLORS = {
  ai: '#2563eb',
  circular: '#059669',
  faith: '#b45309',
  startup: '#dc2626',
  life: '#7c3aed',
};

const nodes = graph.nodes.map((n, idx) => ({
  ...n, i: idx,
  x: (Math.random() - 0.5) * 600,
  y: (Math.random() - 0.5) * 400,
  z: (Math.random() - 0.5) * 320,
  vx: 0, vy: 0, vz: 0,
}));

const byId = new Map(nodes.map(n => [n.id, n]));
const links = graph.links.map(l => ({ ...l, s: byId.get(l.source), t: byId.get(l.target) })).filter(l => l.s && l.t);

// Build adjacency maps
const pillarToPosts = new Map();
const tagToPosts = new Map();
const postToPillars = new Map();
const postToTags = new Map();
const adjacency = new Map();

function pushSet(map, key, val) {
  if (!map.has(key)) map.set(key, new Set());
  map.get(key).add(val);
}
function pushAdj(a, b) {
  pushSet(adjacency, a, b);
  pushSet(adjacency, b, a);
}

for (const link of links) {
  pushAdj(link.s.id, link.t.id);
  if (link.kind === 'pillar' && link.s.type === 'post') {
    pushSet(pillarToPosts, link.t.id, link.s);
    pushSet(postToPillars, link.s.id, link.t.id);
  }
  if (link.kind === 'tag' && link.s.type === 'post') {
    pushSet(tagToPosts, link.t.id, link.s);
    pushSet(postToTags, link.s.id, link.t.id);
  }
}

// === Render layers ===
const svgNS = 'http://www.w3.org/2000/svg';
const svg = document.createElementNS(svgNS, 'svg');
svg.classList.add('graph-links');
stage.appendChild(svg);

const nodesLayer = document.createElement('div');
nodesLayer.className = 'graph-nodes';
stage.appendChild(nodesLayer);

const linkEls = links.map(link => {
  const el = document.createElementNS(svgNS, 'line');
  el.setAttribute('class', 'graph-link graph-link-' + link.kind);
  const w = Number(link.weight || 1);
  el.style.strokeWidth = link.kind === 'tag' ? String(0.8 + w * 0.6) : '1.5';
  svg.appendChild(el);
  return el;
});

const nodeEls = nodes.map(node => {
  const el = document.createElement('button');
  el.type = 'button';
  el.className = 'graph-node graph-node-' + node.type;
  el.textContent = node.type === 'post' ? '' : node.label;
  el.title = node.label;
  if (node.type === 'pillar' && node.pillar) {
    el.style.borderColor = PILLAR_COLORS[node.pillar] || '#2563eb';
    el.style.color = PILLAR_COLORS[node.pillar] || '#2563eb';
  }
  if (node.type === 'post' && node.pillar) {
    el.style.background = PILLAR_COLORS[node.pillar] || '#2563eb';
    el.style.borderColor = PILLAR_COLORS[node.pillar] || '#2563eb';
  }
  nodesLayer.appendChild(el);
  return el;
});

function esc(t) { return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

// === Selection & Inspector ===
let selectedNodeId = '';
let lastSelectedId = '';
let lastSelectedAt = 0;
let focusNodeIds = new Set();
const visibleTypes = new Set(['pillar', 'tag', 'post']);
let visibleNodeIds = new Set(nodes.map(n => n.id));
let visibleLinkFlags = links.map(() => true);
const defaultInspectorHtml = '<p>點擊任一節點查看資訊。</p>';

function setSelected(id) {
  selectedNodeId = id;
  nodeEls.forEach((el, i) => {
    el.classList.toggle('graph-node-selected', nodes[i].id === id);
  });
  inspector?.classList.toggle('graph-inspector-open', Boolean(id));
}

function renderInspector(node) {
  if (!inspectorContent) return;
  if (node.type === 'pillar') {
    const posts = Array.from(pillarToPosts.get(node.id) || []).sort((a,b) => a.label.localeCompare(b.label, 'zh-Hant'));
    inspectorContent.innerHTML = '<div class="info-card"><div class="info-head"><h3>' + esc(node.label) + '</h3><span class="info-badge">支柱</span></div><p class="info-count">關聯文章 ' + posts.length + ' 篇</p>' + (posts.length ? '<ul class="info-list">' + posts.slice(0,40).map(p => '<li><a href="' + p.url + '">' + esc(p.label) + '</a></li>').join('') + '</ul>' : '<p class="info-empty">無文章</p>') + '</div>';
  } else if (node.type === 'post') {
    const pillarLabels = Array.from(postToPillars.get(node.id) || []).map(pid => byId.get(pid)).filter(Boolean).map(n => n.label);
    const tagLabels = Array.from(postToTags.get(node.id) || []).map(tid => byId.get(tid)).filter(Boolean).map(n => n.label);
    inspectorContent.innerHTML = '<div class="info-card"><span class="info-badge">文章</span><a class="info-title" href="' + node.url + '">' + esc(node.label) + '</a><dl class="info-meta"><div><dt>支柱</dt><dd>' + esc(pillarLabels.join('、') || '未分類') + '</dd></div><div><dt>標籤</dt><dd>' + (tagLabels.length ? tagLabels.map(t => '<span class="info-chip">' + esc(t) + '</span>').join(' ') : '無標籤') + '</dd></div></dl></div>';
  } else {
    const posts = Array.from(tagToPosts.get(node.id) || []).sort((a,b) => a.label.localeCompare(b.label, 'zh-Hant'));
    inspectorContent.innerHTML = '<div class="info-card"><div class="info-head"><h3>' + esc(node.label) + '</h3><span class="info-badge">標籤</span></div><p class="info-count">關聯文章 ' + posts.length + ' 篇</p>' + (posts.length ? '<ul class="info-list">' + posts.slice(0,40).map(p => '<li><a href="' + p.url + '">' + esc(p.label) + '</a></li>').join('') + '</ul>' : '<p class="info-empty">無文章</p>') + '</div>';
  }
}

function clearSelection() {
  setSelected('');
  focusNodeIds = new Set();
  if (inspectorContent) inspectorContent.innerHTML = defaultInspectorHtml;
}

function applyFilters() {
  const pv = pillarFilter ? pillarFilter.value : 'all';
  const pid = pv !== 'all' ? 'pillar:' + pv : 'all';
  const q = (searchInput ? searchInput.value : '').trim().toLowerCase();
  const terms = q.split(/\s+/).filter(Boolean);

  const visPosts = new Set();
  const visTags = new Set();
  const visPillars = new Set();

  if (pid === 'all') {
    nodes.forEach(n => {
      if (n.type === 'post') visPosts.add(n.id);
      if (n.type === 'tag') visTags.add(n.id);
      if (n.type === 'pillar') visPillars.add(n.id);
    });
  } else {
    visPillars.add(pid);
    for (const p of (pillarToPosts.get(pid) || [])) {
      visPosts.add(p.id);
      for (const tid of (postToTags.get(p.id) || [])) visTags.add(tid);
    }
  }

  visibleNodeIds = new Set();
  focusNodeIds = selectedNodeId ? new Set([selectedNodeId, ...(adjacency.get(selectedNodeId) || [])]) : new Set();
  let matchCount = 0;

  nodeEls.forEach((el, i) => {
    const n = nodes[i];
    let topicVis = pid === 'all' || (n.type === 'pillar' ? visPillars.has(n.id) : n.type === 'post' ? visPosts.has(n.id) : visTags.has(n.id));
    const typeVis = visibleTypes.has(n.type);
    if (!topicVis || !typeVis) {
      el.style.opacity = '0';
      el.style.pointerEvents = 'none';
      el.classList.remove('graph-node-match', 'graph-node-focus');
      return;
    }
    visibleNodeIds.add(n.id);
    const matched = !q || terms.every(t => n.label.toLowerCase().includes(t));
    el.classList.toggle('graph-node-match', Boolean(q) && matched);
    const inFocus = focusNodeIds.size > 0 && focusNodeIds.has(n.id);
    el.classList.toggle('graph-node-focus', inFocus);
    if (matched) matchCount++;
    let op = q && !matched ? 0.15 : 1;
    if (focusNodeIds.size > 0 && !inFocus) op = Math.min(op, 0.1);
    el.style.opacity = String(op);
    el.style.pointerEvents = 'auto';
  });

  visibleLinkFlags = links.map(() => true);
  linkEls.forEach((el, i) => {
    const link = links[i];
    let vis = true;
    if (pid !== 'all') {
      vis = link.kind === 'pillar'
        ? (link.t.id === pid && visPosts.has(link.s.id))
        : (visPosts.has(link.s.id) && visTags.has(link.t.id));
    }
    if (!visibleTypes.has(link.s.type) || !visibleTypes.has(link.t.type)) vis = false;
    if (!vis) { visibleLinkFlags[i] = false; el.style.display = 'none'; return; }
    el.style.display = 'block';
    const inFocusLink = focusNodeIds.size === 0 || (focusNodeIds.has(link.s.id) && focusNodeIds.has(link.t.id));
    el.style.strokeOpacity = String(inFocusLink ? 0.5 : 0.06);
  });

  if (statusEl) {
    statusEl.textContent = q ? matchCount + ' / ' + visibleNodeIds.size + ' 符合' : '共 ' + visibleNodeIds.size + ' 個節點';
  }
}

// === Node click ===
let suppressUntil = 0;
nodeEls.forEach((el, i) => {
  const node = nodes[i];
  let moved = false, sx = 0, sy = 0;
  el.addEventListener('pointerdown', e => { moved = false; sx = e.clientX; sy = e.clientY; });
  el.addEventListener('pointermove', e => { if (!moved && Math.hypot(e.clientX - sx, e.clientY - sy) >= 5) moved = true; });
  el.addEventListener('pointerup', () => { if (moved) suppressUntil = performance.now() + 260; });
  el.addEventListener('click', () => {
    if (performance.now() < suppressUntil) return;
    const wasSelected = selectedNodeId === node.id;
    const rapidTap = wasSelected && lastSelectedId === node.id && performance.now() - lastSelectedAt < 900;
    setSelected(node.id);
    renderInspector(node);
    applyFilters();
    lastSelectedId = node.id;
    lastSelectedAt = performance.now();
    if (node.url && rapidTap) window.location.href = node.url;
  });
});

inspectorClose?.addEventListener('click', () => { clearSelection(); applyFilters(); stage.focus(); });
stage.addEventListener('click', e => {
  if (e.target instanceof HTMLElement && e.target.closest('.graph-node')) return;
  clearSelection(); applyFilters();
});
pillarFilter?.addEventListener('change', applyFilters);
searchInput?.addEventListener('input', applyFilters);
typeCheckboxes.forEach(input => {
  input.addEventListener('change', () => {
    const checked = typeCheckboxes.filter(c => c.checked).map(c => c.getAttribute('data-node-type')).filter(Boolean);
    if (checked.length === 0) { input.checked = true; return; }
    visibleTypes.clear();
    checked.forEach(t => visibleTypes.add(t));
    if (!visibleTypes.has('post')) clearSelection();
    applyFilters();
  });
});
resetBtn?.addEventListener('click', () => {
  yaw = 0; pitch = 0; zoom = 1;
  if (pillarFilter) pillarFilter.value = 'all';
  if (searchInput) searchInput.value = '';
  typeCheckboxes.forEach(c => { c.checked = true; });
  visibleTypes.clear(); visibleTypes.add('pillar'); visibleTypes.add('tag'); visibleTypes.add('post');
  clearSelection(); applyFilters();
});

// === 3D Camera ===
let yaw = 0, pitch = 0, zoom = 1;
let dragging = false, ptrMoved = false, dragPtrId = -1, lx = 0, ly = 0;

function project(n, w, h) {
  const cy = Math.cos(yaw), sy = Math.sin(yaw), cp = Math.cos(pitch), sp = Math.sin(pitch);
  const x1 = n.x * cy - n.z * sy;
  const z1 = n.x * sy + n.z * cy;
  const y1 = n.y * cp - z1 * sp;
  const z2 = n.y * sp + z1 * cp;
  const p = (760 / (760 + z2)) * zoom;
  return { x: w / 2 + x1 * p, y: h / 2 + y1 * p, s: Math.max(0.3, p), z: z2 };
}

function step() {
  for (const n of nodes) { n.vx *= 0.88; n.vy *= 0.88; n.vz *= 0.88; }
  // Repulsion
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i], b = nodes[j];
      const dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;
      const d2 = dx*dx + dy*dy + dz*dz + 0.1;
      const f = 2200 / d2;
      const inv = 1 / Math.sqrt(d2);
      a.vx += dx*inv*f; a.vy += dy*inv*f; a.vz += dz*inv*f;
      b.vx -= dx*inv*f; b.vy -= dy*inv*f; b.vz -= dz*inv*f;
    }
  }
  // Attraction
  for (const link of links) {
    const a = link.s, b = link.t;
    const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z;
    const d = Math.sqrt(dx*dx+dy*dy+dz*dz) || 1;
    const w = Number(link.weight || 1);
    const target = link.kind === 'pillar' ? 130 : Math.max(120, 220 - w * 50);
    const k = link.kind === 'pillar' ? 0.03 : 0.012 + w * 0.012;
    const f = (d - target) * k;
    a.vx += dx/d*f; a.vy += dy/d*f; a.vz += dz/d*f;
    b.vx -= dx/d*f; b.vy -= dy/d*f; b.vz -= dz/d*f;
  }
  for (const n of nodes) { n.x += n.vx; n.y += n.vy; n.z += n.vz; }
}

function draw() {
  const rect = stage.getBoundingClientRect();
  svg.setAttribute('viewBox', '0 0 ' + rect.width + ' ' + rect.height);
  const p = nodes.map(n => project(n, rect.width, rect.height));
  links.forEach((link, i) => {
    if (!visibleLinkFlags[i]) return;
    const a = p[link.s.i], b = p[link.t.i];
    linkEls[i].setAttribute('x1', String(a.x));
    linkEls[i].setAttribute('y1', String(a.y));
    linkEls[i].setAttribute('x2', String(b.x));
    linkEls[i].setAttribute('y2', String(b.y));
  });
  nodes.forEach((_, i) => {
    const el = nodeEls[i], pp = p[i];
    el.style.left = pp.x + 'px';
    el.style.top = pp.y + 'px';
    el.style.transform = 'translate(-50%,-50%) scale(' + pp.s + ')';
    el.style.zIndex = String(Math.round(pp.z + 1000));
  });
}

function frame() {
  const stride = nodes.length > 160 ? 3 : 2;
  frame._c = (frame._c || 0) + 1;
  if (frame._c % stride === 0) step();
  draw();
  requestAnimationFrame(frame);
}

// Pointer drag
stage.addEventListener('pointerdown', e => {
  if (e.target instanceof HTMLElement && e.target.closest('.graph-node')) return;
  dragging = true; ptrMoved = false; dragPtrId = e.pointerId; lx = e.clientX; ly = e.clientY;
  stage.setPointerCapture(e.pointerId);
});
stage.addEventListener('pointermove', e => {
  if (!dragging || e.pointerId !== dragPtrId) return;
  const dx = e.clientX - lx, dy = e.clientY - ly;
  if (!ptrMoved && Math.hypot(dx, dy) >= 6) ptrMoved = true;
  if (!ptrMoved) return;
  yaw += dx * 0.004; pitch += dy * 0.003; lx = e.clientX; ly = e.clientY;
});
stage.addEventListener('pointerup', e => {
  if (e.pointerId !== dragPtrId) return;
  if (ptrMoved) suppressUntil = performance.now() + 200;
  dragging = false; ptrMoved = false; dragPtrId = -1;
  stage.releasePointerCapture(e.pointerId);
});
stage.addEventListener('pointercancel', e => {
  if (e.pointerId !== dragPtrId) return;
  dragging = false; ptrMoved = false; dragPtrId = -1;
});
stage.addEventListener('wheel', e => {
  e.preventDefault();
  zoom = Math.min(2.2, Math.max(0.5, zoom + (e.deltaY < 0 ? 0.08 : -0.08)));
}, { passive: false });

// Keyboard
stage.addEventListener('keydown', e => {
  if (e.key === 'Escape') { clearSelection(); applyFilters(); }
  if (e.key === '+' || e.key === '=') { e.preventDefault(); zoom = Math.min(2.2, zoom + 0.08); }
  if (e.key === '-' || e.key === '_') { e.preventDefault(); zoom = Math.max(0.5, zoom - 0.08); }
});

applyFilters();
frame();
</script>

<style>
  .graph-page {
    max-width: 1100px;
    margin: 2rem auto;
    padding: 0 1.2rem;
  }
  .graph-page-title {
    font-family: 'Playfair Display', serif;
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary, #0f172a);
    margin: 0 0 0.5rem;
  }
  .graph-intro {
    color: var(--text-secondary, #64748b);
    font-size: 0.92rem;
    margin: 0 0 1.2rem;
  }
  .graph-toolbar {
    display: flex;
    flex-wrap: wrap;
    align-items: end;
    gap: 0.6rem;
    margin-bottom: 0.8rem;
  }
  .graph-toolbar label {
    display: grid;
    gap: 0.2rem;
    font-size: 0.82rem;
    color: var(--text-secondary, #64748b);
  }
  .graph-toolbar input,
  .graph-toolbar select,
  .graph-toolbar button {
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.5rem;
    background: var(--bg-card, #fff);
    color: var(--text-primary, #0f172a);
    min-height: 2rem;
    padding: 0.24rem 0.5rem;
    font-size: 0.86rem;
  }
  .graph-toolbar-link {
    display: inline-flex;
    align-items: center;
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.5rem;
    background: var(--bg-card, #fff);
    color: var(--text-secondary, #64748b);
    min-height: 2rem;
    padding: 0.24rem 0.5rem;
    font-size: 0.84rem;
    text-decoration: none;
  }
  .graph-toolbar-link:hover { color: var(--accent-ai, #2563eb); border-color: var(--accent-ai, #2563eb); }
  .graph-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem 1rem;
    margin-bottom: 0.8rem;
    padding: 0.5rem 0.6rem;
    background: var(--bg-subtle, #f8fafc);
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.6rem;
  }
  .graph-status { margin: 0; font-size: 0.82rem; font-weight: 600; color: var(--text-primary, #0f172a); }
  .graph-type-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem 0.6rem;
    font-size: 0.78rem;
    color: var(--text-secondary, #64748b);
  }
  .graph-type-toggle label {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.12rem 0.35rem;
    border: 1px solid var(--border, #d1d5db);
    border-radius: 999px;
    background: #fff;
  }
  .dot { width: 0.5rem; height: 0.5rem; border-radius: 999px; }
  .dot-pillar { background: #2563eb; }
  .dot-tag { background: #94a3b8; border: 1px solid #cbd5e1; }
  .dot-post { background: #475569; }
  .graph-main { position: relative; }
  .graph-stage {
    position: relative;
    height: min(70vh, 680px);
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.75rem;
    background: radial-gradient(circle at 18% 12%, #f0f4ff, #ffffff 60%);
    overflow: hidden;
    touch-action: none;
  }
  :global(.graph-links) { position: absolute; inset: 0; width: 100%; height: 100%; }
  :global(.graph-link) { stroke: #cbd5e1; stroke-opacity: 0.5; stroke-width: 1; }
  :global(.graph-link-pillar) { stroke: #93c5fd; }
  :global(.graph-link-tag) { stroke: #d1d5db; }
  :global(.graph-nodes) { position: absolute; inset: 0; }
  :global(.graph-node) {
    position: absolute;
    border: 1px solid #d1d5db;
    border-radius: 999px;
    background: #fff;
    color: #1e293b;
    padding: 0.14rem 0.4rem;
    font-size: 0.72rem;
    line-height: 1;
    white-space: nowrap;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    transition: opacity 0.15s;
  }
  :global(.graph-node-post) {
    width: 0.5rem; height: 0.5rem;
    min-width: 0; min-height: 0;
    padding: 0; text-indent: -9999px;
    border-radius: 999px;
  }
  :global(.graph-node-pillar) {
    background: #eff6ff;
    font-weight: 700;
    font-size: 0.82rem;
    padding: 0.22rem 0.6rem;
  }
  :global(.graph-node-tag) {
    background: #f8fafc;
    border-color: #cbd5e1;
    color: #475569;
  }
  :global(.graph-node-selected) { outline: 2px solid #2563eb; outline-offset: 2px; }
  :global(.graph-node-match) { outline: 2px solid #f59e0b; outline-offset: 1px; }
  :global(.graph-node-focus) { outline: 2px solid #f59e0b; outline-offset: 1px; }
  .graph-inspector {
    position: absolute;
    top: 0.75rem; right: 0.75rem;
    width: min(20rem, calc(100% - 1.5rem));
    max-height: calc(100% - 1.5rem);
    overflow: auto;
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.75rem;
    background: var(--bg-card, #fff);
    padding: 0.6rem 0.7rem;
    z-index: 20;
    box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
  }
  .graph-inspector.graph-inspector-open { opacity: 1; pointer-events: auto; }
  .graph-inspector-head { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; margin: 0 0 0.4rem; }
  .graph-inspector h2 { margin: 0; font-size: 0.92rem; }
  .graph-inspector-close {
    border: 1px solid var(--border, #d1d5db);
    border-radius: 0.5rem;
    background: #fff;
    font-size: 0.82rem;
    min-height: 1.6rem;
    padding: 0.15rem 0.4rem;
    cursor: pointer;
  }
  :global(.info-card) { border: 1px solid var(--border, #d1d5db); border-radius: 0.6rem; background: #fff; padding: 0.5rem 0.6rem; }
  :global(.info-head) { display: flex; align-items: center; justify-content: space-between; gap: 0.4rem; }
  :global(.info-head h3) { margin: 0; font-size: 0.9rem; color: #0f172a; }
  :global(.info-badge) {
    display: inline-flex; border: 1px solid #d1d5db; border-radius: 999px;
    background: #f1f5f9; color: #475569; font-size: 0.7rem; padding: 0.12rem 0.38rem;
  }
  :global(.info-count) { margin: 0.3rem 0 0; color: #64748b; font-size: 0.78rem; }
  :global(.info-empty) { margin: 0.3rem 0 0; color: #94a3b8; font-size: 0.78rem; }
  :global(.info-list) { margin: 0.4rem 0 0; padding-left: 1rem; max-height: min(38vh, 16rem); overflow: auto; }
  :global(.info-list li) { margin: 0.3rem 0; }
  :global(.info-list a) { color: #2563eb; text-decoration: underline; line-height: 1.5; font-size: 0.84rem; }
  :global(.info-title) { display: block; color: #0f172a; font-weight: 600; font-size: 0.9rem; text-decoration: none; margin: 0.3rem 0; }
  :global(.info-title:hover) { color: #2563eb; }
  :global(.info-meta) { margin: 0.35rem 0 0; display: grid; gap: 0.3rem; }
  :global(.info-meta div) { margin: 0; }
  :global(.info-meta dt) { margin: 0; color: #64748b; font-size: 0.72rem; }
  :global(.info-meta dd) { margin: 0.1rem 0 0; color: #1e293b; font-size: 0.8rem; }
  :global(.info-chip) {
    display: inline-block; border: 1px solid #d1d5db; border-radius: 999px;
    background: #f8fafc; color: #475569; font-size: 0.72rem; padding: 0.1rem 0.35rem; margin: 0.1rem 0.15rem;
  }
  @media (max-width: 760px) {
    .graph-stage { height: min(60vh, 480px); }
    .graph-inspector {
      position: fixed; left: 0.5rem; right: 0.5rem; top: auto; bottom: 0.5rem;
      width: auto; max-height: 44vh; border-radius: 0.8rem;
      box-shadow: 0 10px 32px rgba(0,0,0,0.2);
      transform: translateY(calc(100% + 1rem));
      z-index: 45; transition: transform 0.2s, opacity 0.2s;
    }
    .graph-inspector.graph-inspector-open { transform: translateY(0); }
  }
</style>
